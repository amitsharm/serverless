"use strict";
/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache License Version 2.0.
 *
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2019 Datadog, Inc.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const layers = __importStar(require("./layers.json"));
const env_1 = require("./env");
const layer_1 = require("./layer");
const tracing_1 = require("./tracing");
const wrapper_1 = require("./wrapper");
const forwarder_1 = require("./forwarder");
var TagKeys;
(function (TagKeys) {
    TagKeys["Service"] = "service";
    TagKeys["Env"] = "env";
})(TagKeys || (TagKeys = {}));
module.exports = class ServerlessPlugin {
    constructor(serverless, _) {
        this.serverless = serverless;
        this.hooks = {
            "after:datadog:clean:init": this.afterPackageFunction.bind(this),
            "after:datadog:generate:init": this.beforePackageFunction.bind(this),
            "after:deploy:function:packageFunction": this.afterPackageFunction.bind(this),
            "after:invoke:local:invoke": this.afterPackageFunction.bind(this),
            "after:package:createDeploymentArtifacts": this.afterPackageFunction.bind(this),
            "after:package:initialize": this.beforePackageFunction.bind(this),
            "before:deploy:function:packageFunction": this.beforePackageFunction.bind(this),
            "before:invoke:local:invoke": this.beforePackageFunction.bind(this),
            "before:offline:start:init": this.beforePackageFunction.bind(this),
            "before:step-functions-offline:start": this.beforePackageFunction.bind(this),
        };
        this.commands = {
            datadog: {
                commands: {
                    clean: {
                        lifecycleEvents: ["init"],
                        usage: "Cleans up wrapper handler functions for DataDog, not necessary in most cases",
                    },
                    generate: {
                        lifecycleEvents: ["init"],
                        usage: "Generates wrapper handler functions for DataDog, not necessary in most cases",
                    },
                },
                lifecycleEvents: ["clean", "generate"],
                usage: "Automatically instruments your lambdas with DataDog",
            },
        };
    }
    beforePackageFunction() {
        return __awaiter(this, void 0, void 0, function* () {
            this.serverless.cli.log("Auto instrumenting functions with Datadog");
            const config = env_1.getConfig(this.serverless.service);
            env_1.setEnvConfiguration(config, this.serverless.service);
            const defaultRuntime = this.serverless.service.provider.runtime;
            const handlers = layer_1.findHandlers(this.serverless.service, defaultRuntime);
            if (config.addLayers) {
                this.serverless.cli.log("Adding Lambda Layers to functions");
                this.debugLogHandlers(handlers);
                layer_1.applyLayers(this.serverless.service.provider.region, handlers, layers);
            }
            else {
                this.serverless.cli.log("Skipping adding Lambda Layers, make sure you are packaging them yourself");
            }
            let tracingMode = tracing_1.TracingMode.NONE;
            if (config.enableXrayTracing && config.enableDDTracing) {
                tracingMode = tracing_1.TracingMode.HYBRID;
            }
            else if (config.enableDDTracing) {
                tracingMode = tracing_1.TracingMode.DD_TRACE;
            }
            else if (config.enableXrayTracing) {
                tracingMode = tracing_1.TracingMode.XRAY;
            }
            tracing_1.enableTracing(this.serverless.service, tracingMode);
        });
    }
    afterPackageFunction() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = env_1.getConfig(this.serverless.service);
            if (config.forwarder) {
                const aws = this.serverless.getProvider("aws");
                const errors = yield forwarder_1.addCloudWatchForwarderSubscriptions(this.serverless.service, aws, config.forwarder);
                for (const error of errors) {
                    this.serverless.cli.log(error);
                }
            }
            if (config.enableTags) {
                this.serverless.cli.log("Adding service and environment tags to functions");
                this.addServiceAndEnvTags();
            }
            const defaultRuntime = this.serverless.service.provider.runtime;
            const handlers = layer_1.findHandlers(this.serverless.service, defaultRuntime);
            wrapper_1.redirectHandlers(handlers, config.addLayers);
        });
    }
    debugLogHandlers(handlers) {
        for (const handler of handlers) {
            if (handler.type === layer_1.RuntimeType.UNSUPPORTED) {
                if (handler.runtime === undefined) {
                    this.serverless.cli.log(`Unable to determine runtime for function ${handler.name}`);
                }
                else {
                    this.serverless.cli.log(`Unable to add Lambda Layers to function ${handler.name} with runtime ${handler.runtime}`);
                }
            }
        }
    }
    /**
     * Check for service and env tags on provider level (under tags and stackTags),
     * as well as function level. Automatically create tags for service and env with
     * properties from deployment configurations if needed; does not override any existing values.
     */
    addServiceAndEnvTags() {
        let providerServiceTagExists = false;
        let providerEnvTagExists = false;
        const provider = this.serverless.service.provider;
        const providerTags = provider.tags;
        if (providerTags !== undefined) {
            providerServiceTagExists = providerTags[TagKeys.Service] !== undefined;
            providerEnvTagExists = providerTags[TagKeys.Env] !== undefined;
        }
        const providerStackTags = provider.stackTags;
        if (providerStackTags !== undefined) {
            providerServiceTagExists = providerServiceTagExists || providerStackTags[TagKeys.Service] !== undefined;
            providerEnvTagExists = providerEnvTagExists || providerStackTags[TagKeys.Env] !== undefined;
        }
        if (!providerServiceTagExists || !providerEnvTagExists) {
            this.serverless.service.getAllFunctions().forEach((functionName) => {
                const functionDefintion = this.serverless.service.getFunction(functionName);
                if (!functionDefintion.tags) {
                    functionDefintion.tags = {};
                }
                if (!providerServiceTagExists && !functionDefintion.tags[TagKeys.Service]) {
                    functionDefintion.tags[TagKeys.Service] = this.serverless.service.getServiceName();
                }
                if (!providerEnvTagExists && !functionDefintion.tags[TagKeys.Env]) {
                    functionDefintion.tags[TagKeys.Env] = this.serverless.getProvider("aws").getStage();
                }
            });
        }
    }
};
//# sourceMappingURL=index.js.map