"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const logGroupKey = "AWS::Logs::LogGroup";
const logGroupSubscriptionKey = "AWS::Logs::SubscriptionFilter";
function isLogGroup(value) {
    return value.Type === logGroupKey;
}
function addCloudWatchForwarderSubscriptions(service, aws, functionArn) {
    return __awaiter(this, void 0, void 0, function* () {
        const resources = service.provider.compiledCloudFormationTemplate.Resources;
        const errors = [];
        for (const [name, resource] of Object.entries(resources)) {
            if (!isLogGroup(resource) || !resource.Properties.LogGroupName.startsWith("/aws/lambda/")) {
                continue;
            }
            const logGroupName = resource.Properties.LogGroupName;
            const scopedSubName = `${name}Subscription`;
            const expectedSubName = `${service.getServiceName()}-${aws.getStage()}-${scopedSubName}-`;
            const canSub = yield canSubscribeLogGroup(aws, logGroupName, expectedSubName);
            if (!canSub) {
                errors.push(`Subscription already exists for log group ${logGroupName}. Skipping subscribing Datadog forwarder.`);
                continue;
            }
            const subscription = {
                Type: logGroupSubscriptionKey,
                Properties: {
                    DestinationArn: functionArn,
                    FilterPattern: "",
                    LogGroupName: { Ref: name },
                },
            };
            resources[scopedSubName] = subscription;
        }
        return errors;
    });
}
exports.addCloudWatchForwarderSubscriptions = addCloudWatchForwarderSubscriptions;
function canSubscribeLogGroup(aws, logGroupName, expectedSubName) {
    return __awaiter(this, void 0, void 0, function* () {
        const subscriptionFilters = yield describeSubscriptionFilters(aws, logGroupName);
        let hasUnknownSubscriptions = false;
        for (const subscription of subscriptionFilters) {
            const filterName = subscription.filterName;
            if (filterName.startsWith(expectedSubName)) {
                return true;
            }
            // We don't own this log group. It might not be possible to set a forwarder
            hasUnknownSubscriptions = true;
        }
        // No log groups, so it's possible to subscribe.
        return !hasUnknownSubscriptions;
    });
}
exports.canSubscribeLogGroup = canSubscribeLogGroup;
function describeSubscriptionFilters(aws, logGroupName) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const result = yield aws.request("CloudWatchLogs", "describeSubscriptionFilters", {
                logGroupName,
            });
            return result.subscriptionFilters;
        }
        catch (err) {
            // An error will occur if the log group doesn't exist, so we swallow this and return an empty list.
            return [];
        }
    });
}
exports.describeSubscriptionFilters = describeSubscriptionFilters;
//# sourceMappingURL=forwarder.js.map